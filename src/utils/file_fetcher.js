const fs = require('fs')

class DatasetPathCollector {
  constructor(datasetInfo) {
    this.folderPath = datasetInfo.folderPath
    this.labelFile = datasetInfo.labelFile
    this.fileExtension = datasetInfo.details.fileExtension
    this.fileList = []
    this.header = []
    this.colFilename = datasetInfo.details.colFilename
    this.colLabel = datasetInfo.details.colLabel

    // TODO: this field is for development only
    this.defaultBatchSize = 20
  }

  parseFileList () {
    return new Promise((resolve, reject) => {
      readCsv(this.labelFile).then((result) => {
        let folderPath = this.folderPath
        let ext = this.fileExtension

        // Remove the last element, because it's an empty string generated by `string.split()`
        result.splice(result.length - 1, 1)
        this.header = result.splice(0, 1)[0]

        // remove utf-8 BOM
        if (this.header[0].charCodeAt(0) === 0xFEFF) {this.header[0] = this.header[0].substr(1)}
        let idxFilename = this.header.indexOf(this.colFilename)
        let idxLabel = this.header.indexOf(this.colLabel)

        this.fileList = result.map(function(row, index) {
          return {
            index: index,
            root: folderPath,
            filename: `${row[idxFilename]}${ext}`,
            label: row[idxLabel]
          }
        })

        resolve(true)
      }).catch((err) => {
        reject(err)
      })
    })
  }

  getBatch (batchSize) {}
}

function readJson (fn, withEscape = false) {
  return new Promise((resolve, reject) => {
    try {
      let fileContent = fs.readFileSync(fn, {encoding: 'utf8'})
      let result = JSON.parse(fileContent)

      // If there are escape notations in the file content, result from
      // the first parsing operation will be pure string. So that we have
      // to use `JSON.parse` again.
      if (withEscape) {
        result = JSON.parse(result)
      }
      resolve(result)
    }
    catch (err) {
      reject(err)
    }
  })
}

function readCsv (fn, delimiter = ',') {
  return new Promise((resolve, reject) => {
    try {
      let fileContent = fs.readFileSync(fn, {encoding: 'utf8'})
      let pattern = new RegExp(
        (
          // Delimiters.
          "(\\" + delimiter + "|\\r?\\n|\\r|^)" +
          // Quoted fields.
          "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
          // Standard fields.
          "([^\"\\" + delimiter + "\\r\\n]*))"
        ), 'gi'
      )
      let arrData = [[]]
      let arrMatches = null
      while (arrMatches = pattern.exec(fileContent)) {
        let matchedDelimiter = arrMatches[1]
        let matchedValue = null
        if (matchedDelimiter.length && matchedDelimiter != delimiter) { arrData.push([]) }
        if (arrMatches[2]) {
          matchedValue = arrMatches[2].replace(new RegExp('\"\"', 'g'), '\"')
        } else {
          matchedValue = arrMatches[3]
        }
        arrData[arrData.length - 1].push(matchedValue)
      }
      resolve(arrData)
    }
    catch (err) {
      reject(err)
    }
  })
}

export default {
  DatasetPathCollector,
  readJson,
  readCsv
}